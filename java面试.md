# Java面试题库

 ## 面向对象的特征有哪些方面：
        + 抽象
          - 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象
        + 继承
          - 继承是从已有的类得到继承信息创建新类的过程。提供继承信息的类被称为父类；得到继承信息的类被称为子类
        + 封装
          - 通常是把数据和操作数据的方法绑定起来，对数据的访问只能通过定义的接口。
        + 多态
          - 允许不同子类型的对象对统一信息作出不同的响应。简单来说就是用同样的对象引用调用同样的方法但是做了不同的事情。
  ## 访问修饰符public,private,protected，以及不写（默认）时的区别
        - public 可以在当前类，同包，子类，其他包调用，protected 在其他包无法调用，private只能在当前类调用
  ## String是最基本的数据类型吗
        - 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean;除了基本数据类型，剩下都是引用类型
  ## Jvaa有没有goto
        - goto是Java中的保留字，在目前版本的Java中没有使用。
  ## int和Integer有什么区别
        - Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本的数据类型，为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类，
  ## &和&&的区别
        - &运算符有两种用法：1.按位与；2.逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是很大的。二者都要求运算符左右两边都是true整个表达式的值才是true。&&之所以成为短路运算时因为，如果&&左边是false，右边的表达式会直接短路掉，不参与运算。
  ## 解释内存中栈、堆和方法区的用法
        - 通常我们定义一个基本数据类型的变量，一个对象的引用，还有函数的调用的现场保存都是用JVM的栈空间；而通过new关键字和构造器创建的对象则放在放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor、Tenured；方法去和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代母等数据。

## Math.round (11.5)的运算结果是多少，Math.round(-11.5)又是多少
    - 第一个为12，第二个为-11，四舍五入的方法是参数上加0.5然后向下取整

## switch 是否能作用在byte上，能否作用在long上，能否作用在String上？
    - 在Java5以前，switch（expr）中，expr只能是byte、short、int。从java 5 开始，java引入了枚举类型，expr也可以是enum类型，Java 7开始，还可以是String，但long还是不可以

## 最有效率的方法计算2乘以8？
    - 2<<3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。


## 数组有没有length（）方法？String有没有length（）方法？
    - 数组没有，只有length属性。String有length（）方法。

## 在Java中，如何跳出当前的多重嵌套循环？
    - 在最外城加一个标记如A，然后用break A，可以跳出多重循环

## 构造器是否可以被重写
    - 构造器不能被继承，因此不能被重写，但可以被重载

## 两个对象值相同，但却可有不同的hash code，这句话对不对？
    - 不对，如果两个对象x和y满足x。equals（y）==true，他们的hash code必然相同

## 是否可以继承String类
    - 不能，String是final类

## 当一个对象被当做参数传递到一个方法后，此方法可以改变这个对象的属性，并可以返回变化后的结果，那么这里到底是值传递还是引用传递？
    - 是值传递。Java的方法调用只支持参数值传递

## String和StringBuilder、StringBuffer的区别？
    - Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder,他们可以存储和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。

## 重载(overload)和重写(override)的区别，重载的方法能否根据返回类型进行区分
    - 方法的重载和重写都是实现多态的方式，区别在于前者是实现编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载；重写发生在子类和父类之间，重写要求子类被重写的方法与父类被重写方法有相同的返回类型。重载堆返回类型没有要求。

## 