# Java面试题库

 ## 面向对象的特征有哪些方面：
+ 抽象
    - 抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象
+ 继承
    - 继承是从已有的类得到继承信息创建新类的过程。提供继承信息的类被称为父类；得到继承信息的类被称为子类
+ 封装
    - 通常是把数据和操作数据的方法绑定起来，对数据的访问只能通过定义的接口。
+ 多态
    - 允许不同子类型的对象对统一信息作出不同的响应。简单来说就是用同样的对象引用调用同样的方法但是做了不同的事情。

## 访问修饰符public,private,protected，以及不写（默认）时的区别
- public 可以在当前类，同包，子类，其他包调用，protected 在其他包无法调用，private只能在当前类调用

## String是最基本的数据类型吗
- 不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean;除了基本数据类型，剩下都是引用类型

## Java有没有goto
- goto是Java中的保留字，在目前版本的Java中没有使用。
  
## int和Integer有什么区别
- Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本的数据类型，为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类，
  
## &和&&的区别
- &运算符有两种用法：1.按位与；2.逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是很大的。二者都要求运算符左右两边都是true整个表达式的值才是true。&&之所以成为短路运算时因为，如果&&左边是false，右边的表达式会直接短路掉，不参与运算。

## 解释内存中栈、堆和方法区的用法
- 通常我们定义一个基本数据类型的变量，一个对象的引用，还有函数的调用的现场保存都是用JVM的栈空间；而通过new关键字和构造器创建的对象则放在放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor、Tenured；方法去和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代母等数据。

## Math.round (11.5)的运算结果是多少，Math.round(-11.5)又是多少
- 第一个为12，第二个为-11，四舍五入的方法是参数上加0.5然后向下取整

## switch 是否能作用在byte上，能否作用在long上，能否作用在String上？
- 在Java5以前，switch（expr）中，expr只能是byte、short、int。从java 5 开始，java引入了枚举类型，expr也可以是enum类型，Java 7开始，还可以是String，但long还是不可以

## 最有效率的方法计算2乘以8？
- 2<<3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。


## 数组有没有length（）方法？String有没有length（）方法？
- 数组没有，只有length属性。String有length（）方法。

## 在Java中，如何跳出当前的多重嵌套循环？
- 在最外城加一个标记如A，然后用break A，可以跳出多重循环

## 构造器是否可以被重写
- 构造器不能被继承，因此不能被重写，但可以被重载

## 两个对象值相同，但却可有不同的hash code，这句话对不对？
- 不对，如果两个对象x和y满足x。equals（y）==true，他们的hash code必然相同

## 是否可以继承String类
- 不能，String是final类

## 当一个对象被当做参数传递到一个方法后，此方法可以改变这个对象的属性，并可以返回变化后的结果，那么这里到底是值传递还是引用传递？
- 是值传递。Java的方法调用只支持参数值传递

## String和StringBuilder、StringBuffer的区别？
- Java平台提供了两种类型的字符串：String和StringBuffer/StringBuilder,他们可以存储和操作字符串。其中String是只读字符串，也就意味着String引用的字符串内容是不能被改变的。而StringBuffer/StringBuilder类表示的字符串对象可以直接进行修改。

## 重载(overload)和重写(override)的区别，重载的方法能否根据返回类型进行区分
- 方法的重载和重写都是实现多态的方式，区别在于前者是实现编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表则视为重载；重写发生在子类和父类之间，重写要求子类被重写的方法与父类被重写方法有相同的返回类型。重载堆返回类型没有要求。

## char 型变量中能不能存贮一个中文汉字，为什么？
- char类型可以存储一个中文汉字，因为Java中使用的编码是Unicode（不选择任何特定的编码，直接使用字符在字符集中的编号，这是统一的唯一方法），一个char类型占2个字节（16比特），所以放一个中文是没问题的。

## 抽象类（abstract class）和接口（interface）有什么异同？
- 抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是private、默认、protected、public的，而接口中的成员全都是public的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。

## 静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？
- Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。而通常的内部类需要在外部类实例化后才能实例化，其语法看起来挺诡异的，如下所示。

## Java 中会存在内存泄漏吗，请简单描述。
- 理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题（这也是Java被广泛使用于服务器端编程的一个重要原因）；然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收，因此也会导致内存泄露的发生。例如Hibernate的Session（一级缓存）中的对象属于持久态，垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象，如果不及时关闭（close）或清空（flush）一级缓存就可能导致内存泄露。下面例子中的代码也会导致内存泄露。

## 抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被synchronized修饰？
- 都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。

## 阐述静态变量和实例变量的区别。
- 静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。

## 是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？
- 不可以，静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。

## 如何实现对象克隆？
1. 实现Cloneable接口并重写Object类中的clone()方法；
2. 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。

## GC是什么？为什么要有GC？
- GC是垃圾回收机制。
- 内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，GC能够自动监测对象是否超过作用域从而达到自动回收内存的目的。同样，GC理论上可以防止内存泄漏，，有效的使用可以使用的内存。

## String s = new String("xyz");创建了几个字符串对象？
- 两个对象，一个是静态区的"xyz"，一个是用new创建在堆上的对象。

## 接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？
- 接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。

## 一个".java"源文件中是否可以包含多个类（不是内部类）？有什么限制？
- 可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。

## Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？
- 可以继承其他类或实现其他接口，在Swing编程和Android开发中常用此方式来实现事件监听和回调。

## 内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？
- 一个内部类对象可以访问创建它的外部类对象的成员，包括私有成员。

## Java 中的final关键字有哪些用法？
  1. 修饰类：表示该类不能被继承；
  2. 修饰方法：表示方法不能被重写；
  3. 修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。

## 指出下面程序的运行结果。
```java
    class A {

    static {
        System.out.print("1");
    }

    public A() {
        System.out.print("2");
    }
}

class B extends A{

    static {
        System.out.print("a");
    }

    public B() {
        System.out.print("b");
    }
}

public class Hello {

    public static void main(String[] args) {
        A ab = new B();
        ab = new B();
    }

}
```
- 执行结果：1a2b2b。创建对象时构造器的调用顺序是：先初始化静态成员，然后调用父类构造器，再初始化非静态成员，最后调用自身构造器。

## 数据类型之间的转换：
+ 如何将字符串转换为基本数据类型？
    - 调用基本数据类型对应的包装类中的方法parseXXX(String)或valueOf(String)即可返回相应基本类型；
+ 如何将基本数据类型转换为字符串？
    - 一种方法是将基本数据类型与空字符串（""）连接（+）即可获得其所对应的字符串；另一种方法是调用String 类中的valueOf()方法返回相应字符串 

## 比较一下Java和JavaSciprt。
- JavaScript 与Java是两个公司开发的不同的两个产品。Java 是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。
下面对两种语言间的异同作如下比较：
- 基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互作用的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。
- 解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）
- 强类型变量和类型弱变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。

## 什么时候用断言（assert）？
- 断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。

## Error和Exception有什么区别？
- Error表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。

## 索引是帮助MySQL高效获取数据的排好序的数据结构
- 索引数据结构
    - 二叉树
    - 红黑树（平衡二叉树）
    - Hash表
    - B-Tree

## MyISAM索引文件和数据文件是分离的

## InnoDB表必须要有主键，并且推荐使用整型的自增主键
- 由于表数据文件本身就是按照B+Tree组织的索引结构文件
- 整型的存储空间更小，比对速度更快
- 自增原因：B+Tree叶子结点有一个双向指针，更适合范围查找

